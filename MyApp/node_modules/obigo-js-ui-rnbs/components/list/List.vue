<template>
  <div class='obg-list' :class='{"isEmpty": isEmpty}' >
    <div class='scroll-container' >
        <slot></slot>
        <div class='dummy-item' v-if="hideDummyItem == false" ></div>
    </div>
  </div>
</template>

<script>
import IScroll from '../../features/iscroll'
import spm from './scroll-position-manager'
import listItem from './list-item'
import Events from '../../features/events'
import {hardkeyCode} from '../../features/hardkey'
/**
 * @see Renault, Nissan
 * @class list
 * @classdesc components/list
 * @param {boolean} [hideDummyItem=false] hide/show last dummy item.
 * @param {boolean} [scrollbars=true]
 * @param {boolean} [fadeScrollbars=true]
 * @param {boolean} [bounce=true]
 * @param {boolean} [preventDefault=true]
 * @param {boolean} [enableJogUpDown=false]
 * @param {number} [targetElementIndex] scroll to targetElement when updated
 * @param {string} [listKey] unique list id in page.<br/>if do not define this property, List component can not save last scroll position.<br/>and be careful do not duplicate with another List in same page.
 * @example
 * <obg-list>
 *  <obg-list-item>item1</obg-list-item>
 *  <obg-list-item>item2</obg-list-item>
 *  <obg-list-item>item3</obg-list-item>
 * </obg-list>
 */
export default {
  name: 'obg-list',
  props: {
    hideDummyItem: {
      type: Boolean,
      default: false
    },
    targetElementIndex: {
      type: Number
    },
    listKey: {
      type: String
    },
    scrollbars: {
      type: Boolean,
      default: true
    },
    fadeScrollbars: {
      type: Boolean,
      default: true
    },
    bounce: {
      type: Boolean,
      default: true
    },
    preventBounce: {
      type: Boolean,
      default: false
    },
    preventDefault: {
      type: Boolean,
      default: true
    },
    enableJogUpDown: {
      type: Boolean,
      default: false
    }
  },
  data () {
    return {
      isEmpty: false
    }
  },
  methods: {
    getScroll () {
      return this.$scroll
    },
    focusIn (index, direction) {
      /*
       * 리스트 아이템의 높이는 모두 같다는 전제
       */

      var pageExist = this.$scroll.pages && this.$scroll.pages.length > 0
      var itemHeight = pageExist ? this.$scroll.pages[0][0].height : this.$children[0].$el.offsetHeight
      var wrapperHeight = this.$scroll.wrapperHeight - (this.hasFixed ? itemHeight : 0)
      var fixedFocusPos = 0
      var remain = itemHeight - ((wrapperHeight - (this.hideDummyItem ? 0 : 78)) % itemHeight)
      var itemsInPage = Math.floor((wrapperHeight - (this.hideDummyItem ? 0 : 78)) / itemHeight) - (remain === itemHeight ? 1 : 0)
      var nowPage = this.$scroll.currentPage.pageY

      if (direction === 'right') {
        fixedFocusPos = itemsInPage
        if (index - nowPage > itemsInPage - 1) {
          if (pageExist) {
            this.$scroll.goToPage(0, index - fixedFocusPos + 1, 200)
          } else {
            this.$scroll.scrollTo(0, -((index - fixedFocusPos + 1) * itemHeight), 200)
          }
        } else if (index > -1 && index < nowPage) {
          if (pageExist) {
            this.$scroll.goToPage(0, index, 0)
          } else {
            this.$scroll.scrollTo(0, index * itemHeight, 0)
          }
        }
      } else if (direction === 'left') {
        fixedFocusPos = 2
        if (index === nowPage || index === nowPage - 1) {
          if (pageExist) {
            this.$scroll.goToPage(0, nowPage - 1, 200)
          } else {
            this.$scroll.scrollTo(0, -((nowPage - 1) * itemHeight), 200)
          }
        }
      } else {
        if (index - nowPage > itemsInPage - 1) {
          if (pageExist) {
            this.$scroll.goToPage(0, index, 200)
          } else {
            this.$scroll.scrollTo(0, -(index * itemHeight), 200)
          }
        }
      }
    },
    makeScroll () {
      if (this.$el.querySelectorAll('.scroll-container > .obg-list-item, .scroll-container > .obg-accordion').length === 0 || this.$slots.default === undefined || this.$slots.default.length === 0) {
        this.isEmpty = true
        return
      }
      this.isEmpty = false
      this.$scroll = new IScroll(this.$el, {
        probeType: 2,
        bounce: this.bounce,
        preventBounce: this.preventBounce,
        mouseWheel: false,
        scrollbars: this.scrollbars,
        fadeScrollbars: this.fadeScrollbars,
        interactiveScrollbars: false,
        scrollXThreshold: listItem.horiThreshold,
        scrollYThreshold: listItem.vertiThreshold,
        preventDefault: this.preventDefault,
        click: true,
        disableMouse: !(!('ontouchstart' in window) && ('onmousedown' in window)),
        disablePointer: true,
        disableTouch: !(('ontouchstart' in window) && ('onmousedown' in window)),
        snap: '.obg-list-item, .obg-accordion',
        deceleration: 0.001,
        dummyItem: !this.hideDummyItem
      })
      this.$scroll.on('scrollEnd', this.scrollEnd)
      this.$scroll.on('scrollStart', this.scrollStart)
      var lastPos = 0
      if (this.$router) { // 팝업의 컴포넌트로 list를 생서할 시 router는 전달되지 않으므로 라우터 검사 후 라우터 사용
        lastPos = spm.get(this.listKey + this.$router.history.current.fullPath)
      }
      if (this.$router && this.$router.isBack === true && lastPos !== undefined) {
        this.$scroll.goToPage(0, lastPos.pageY, 0)    // scrollTo를 사용하면 iscroll의 pages속성을 업데이트하지않아 snap이 적용된 스크롤 동작이 정상적이지 않음.
      } else {
        this.scrollToElement(this.targetElementIndex)
      }
    },
    scrollStart () {
      Events.$emit('list:scrollstart')
    },
    scrollEnd () {
      if (this.listKey !== undefined && this.$router) {
        spm.set(this.listKey + this.$router.history.current.fullPath, this.$scroll.currentPage)
      }
      Events.$emit('list:scrollend')
    },
    refreshScroll () {
      if (this.$scroll) {
        this.itemsEl = this.$el.querySelectorAll('.obg-list-item, .obg-accordion')
        if (this.itemsEl.length === 0 || this.$slots.default === undefined || this.$slots.default.length === 0) {
          this.isEmpty = true
          this.$scroll.destroy()
          this.$scroll = undefined
          return
        } else {
          this.isEmpty = false
          this.$scroll.refresh()
        }
      } else {
        this.makeScroll()
        this.itemsEl = this.$el.querySelectorAll('.obg-list-item, .obg-accordion')
      }
    },
    scrollToElement (index) {
      if (index !== undefined && this.$slots.default[index]) {
        this.$scroll.scrollToElement(this.$slots.default[index].elm, 0)
      }
    },
    prev () {
      this.$scroll && this.$scroll.prev()
    },
    next () {
      this.$scroll && this.$scroll.prev()
    },
    goToIndex (index) {
      this.$scroll && this.$scroll.goToPage(0, index, 200)
    },
    hasFixedItem () {
      if (this.$el.querySelector('.fixed')) {
        this.hasFixed = true
      } else {
        this.hasFixed = false
      }
    },
    /**
     * list 에서 titl up/down 동작 처리 for Nissan
     * @param code
     * @param mode
     */
    movePageByCsw ({code, mode}) {
      // list에서 titl up/down 동작 처리 for Nissan
      // const fcName = '[List.movePageByCsw]'
      if (mode !== hardkeyCode.mode.HARDKEY_MODE_RELEASE) {
        return
      }
      if (!this.$scroll) {
        // console.log(`${fcName} undefined this.$scroll`)
        return
      }
      if (!this.$focus.isFocusOn()) {
        // console.log(`${fcName} is not focus on`)
        return
      }
      let isUp = (code === hardkeyCode.code.HARDKEY_ROTARY_UP)
      const {wrapperHeight, pages, maxScrollY, currentPage: {y, pageY}} = this.$scroll
      const lastIndex = pages[0].length - 1
      let itemIndex = pageY
      let isGoFirst = false
      let isGoLast = false
      let focusIndex = -1
      let nextIndex = -1
      let diffHeight = y - maxScrollY
      // 1. 첫 페이지 -> 마지막 페이지 또는 마지막페이지 -> 첫 페이지 와 같은 loop 동작 확인
      isGoLast = isUp && itemIndex === 0
      isGoFirst = !isUp && itemIndex === lastIndex
      // 2. 이외 페이지에서 첫 페이지 또는 마지막 페이지으로 이동인지 확인
      if (!isGoFirst && !isGoLast) {
        isGoFirst = isUp && -y < wrapperHeight
        isGoLast = !isUp && diffHeight < wrapperHeight
      }
      if (isGoFirst || isGoLast) {
        // 3. 첫페이지 또는 마지막페이지으로 가는 경우
        focusIndex = isGoFirst ? 0 : lastIndex
        nextIndex = isGoFirst ? 0 : lastIndex
      } else {
        // 4. 첫페이지과 마지막페이지가 아닌 이외의 페이지로 가는 경우
        let children = this.$el.firstChild.childNodes
        let count = 0
        let height = 0
        // 최대 이동가능한 높이
        let availableHeight = isUp ? wrapperHeight : (diffHeight < wrapperHeight) ? diffHeight : wrapperHeight
        while (height < availableHeight) {
          let elIndex = isUp ? itemIndex - count : itemIndex + count
          if (elIndex > lastIndex || elIndex < 0) {
            break
          }
          let el = children[elIndex]
          height += el.clientHeight || 0
          count++
        }
        focusIndex = isUp ? count <= itemIndex ? itemIndex - 1 : count : itemIndex + count
        nextIndex = isUp ? itemIndex - count : itemIndex + count
      }
      this.$focus.setFocusOnByElement(this.$el.firstChild.childNodes[focusIndex])
      this.$scroll.goToPage(0, nextIndex, 0, 0)
    },
    bindHardkeyEvent () {
      // console.log('[List.bindHardkeyEvent]')
      this.$hardkey.addHardkeyListener(hardkeyCode.code.HARDKEY_ROTARY_UP, this.movePageByCsw)
      this.$hardkey.addHardkeyListener(hardkeyCode.code.HARDKEY_ROTARY_DOWN, this.movePageByCsw)
    },
    unbindHardkeyEvent () {
      // console.log('[List.unbindHardkeyEvent]')
      this.$hardkey.removeHardkeyListener(hardkeyCode.code.HARDKEY_ROTARY_UP, this.movePageByCsw)
      this.$hardkey.removeHardkeyListener(hardkeyCode.code.HARDKEY_ROTARY_DOWN, this.movePageByCsw)
    }
  },
  updated () {
    let nowScrollHeight = this.$el.firstChild.scrollHeight
    if (this.beforeScrollHeight !== nowScrollHeight) {
      this.refreshScroll()
      this.beforeScrollHeight = nowScrollHeight
    }
    if (this.isEmpty === false) {
      this.scrollToElement(this.targetElementIndex)
    }
    this.hasFixedItem()
  },
  mounted () {
    this.itemsEl = []
    this.beforeFocusIndex = 0
    this.makeScroll()
    this.beforeScrollHeight = this.$el.firstChild.scrollHeight
    this.$on('updateScroll', this.refreshScroll)  // accordion에서 list item이 동적으로 변경시 updateScroll 이벤트 발생.
    this.hasFixedItem()
    this.itemsEl = this.$el.querySelectorAll('.obg-list-item, .obg-accordion')
    this.movePageByCsw = this.movePageByCsw.bind(this)
    this.bindHardkeyEvent = this.bindHardkeyEvent.bind(this)
    this.unbindHardkeyEvent = this.unbindHardkeyEvent.bind(this)
    if (this.enableJogUpDown) {
      this.bindHardkeyEvent()
    }
  },
  beforeDestroy () {
    if (this.$scroll) {
      this.$scroll.destroy()
      this.$scroll = undefined
    }
    if (this.enableJogUpDown) {
      this.bindHardkeyEvent()
    }
  }
}
</script>
<style lang="scss" scoped >
  .obg-list{
    position:relative;
    overflow:hidden;
    color:white;
    .dummy-item{
      width:100%;
      height:78px;
    }
  }
  .isEmpty {
    display:flex;
    justify-content:center;
    align-items:center;
  }
</style>

