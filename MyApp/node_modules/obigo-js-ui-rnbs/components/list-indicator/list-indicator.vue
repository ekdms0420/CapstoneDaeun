<template>
  <div
    class="obg-list-indicator"
    :class="{'disable': nonScroll || disable}"
  >
    <obg-button
      class="double-arrow up scroll"
      @click="onClickDoubleArrow(true)"
      icon="sc-up-double"
      @mousedown="start"
      @mouseup="end"
      @touchstart="start"
      @mouseleave="end"
      @touchend="end"
      @touchcancel="end"
      @touchleave="end"
    ></obg-button>
    <div class="list-scroll-container">
      <div
        class="runway"
        ref="runway"
        @click="onClickRunway"
      >
      </div>
      <div
        class="indicator"
        ref="indicator"
        :style="{height: indicatorHeight + 'px', marginTop: indicatorTop + 'px', transitionDuration: indicatorDuration + 'ms' }"
        @mousedown="_start"
        @touchstart="_start"
      >
      </div>
    </div>
    <obg-button
      class="double-arrow down scroll"
      @click="onClickDoubleArrow(false)"
      icon="sc-down-double"
      @mousedown="start"
      @mouseup="end"
      @touchstart="start"
      @mouseleave="end"
      @touchend="end"
      @touchcancel="end"
      @touchleave="end"
    ></obg-button>
  </div>
</template>

<script>
  /**
   * @see Nissan only
   * @class list-indicator
   * @classdesc components/indicator
   * @param {object} [$scroll] required
   * @param {number} [itemHeight=150]
   * @param {number} [minScrollHeight=674]
   * @param {number} [value=0]
   * @param {number} [bottomHeight=300]
   * @param {number} [maxIndicatorHeight=125]
   * @param {number} [minIndicatorHeight=50]
   * @param {boolean} [disable=false]
   *
   * @example
   *  <obg-list-indicator>
   *  </obg-list-indicator>
   */
  const isTouchSupported = 'ontouchstart' in window
  const moveEvent = isTouchSupported ? 'touchmove' : 'mousemove'
  const endEvent = isTouchSupported ? 'touchend' : 'mouseup'

  import button from '../button'

  export default{
    name: 'obg-list-indicator',
    components: {
      'obg-button': button
    },
    props: {
      itemHeight: {
        type: Number,
        default: 150
      },
      minScrollHeight: {
        type: Number,
        default: 674
      },
      value: {
        type: Number,
        default: 0
      },
      $scroll: {
        type: Object,
        require: true
      },
      bottomHeight: {
        type: Number,
        default: 300
      },
      maxIndicatorHeight: {
        type: Number,
        default: 125
      },
      minIndicatorHeight: {
        type: Number,
        default: 50
      },
      disable: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      model: {
        get () {
          return this.value
        },
        set (value) {
          this.$emit('input', value)
        }
      }
    },
    data () {
      return {
        now: 0,
        scrollableHeight: 0,
        scrolling: false,
        indicatorHeight: 65,
        indicatorTop: 0,
        maxIndicatorTop: 0,
        indicatorDuration: 500,
        nonScroll: true,
        point: {
          startY: 0,
          moveY: 0,
          startIndicatorTop: 0
        },
        indicatorContainerHeight: 395
      }
    },
    watch: {
      $scroll (val, oldVal) {
        if (val && val.scroller) {
          this.$nextTick(() => {
            this._initScroll()
            this.scroller = this.$scroll.scroller
            this._initObserve()
          })
        } else {
          console.warn('[ObigoUI] You should set Iscroll obejct to iscroll props')
          this.nonScroll = true
        }
      }
    },
    methods: {
      start (evt) {
        evt.currentTarget.classList.add('active')
      },
      end (evt) {
        evt.currentTarget.classList.remove('active')
      },
      _initScroll () {
        this.nonScroll = (this.$scroll.scroller.getBoundingClientRect().height <= this.$scroll.wrapper.getBoundingClientRect().height)

        if (this.$scroll.on && !this.nonScroll) {
          this.bindIScrollEventHandler()
        }

        this.scrollableHeight = this.$scroll.scroller.offsetHeight - this.$scroll.wrapper.offsetHeight
        const newIndicatorHeight = Math.floor(100 / this.scrollableHeight) * this.indicatorContainerHeight
        this.indicatorHeight = (newIndicatorHeight > this.maxIndicatorHeight) ? this.maxIndicatorHeight : (newIndicatorHeight < this.minIndicatorHeight) ? this.minIndicatorHeight : newIndicatorHeight
        this.maxIndicatorTop = this.indicatorContainerHeight - this.indicatorHeight
        this.indicatorTop = Math.floor(this.maxIndicatorTop * Math.abs(this.$scroll.y) / this.scrollableHeight)
      },
      _initObserve () {
        const config = { childList: true }
        var callback = (mutationsList) => {
          for (var mutation of mutationsList) {
            if (mutation.type === 'childList') {
              this.unbindIScrollEventHandler()
              this._initScroll()
            }
          }
        }
        this.observer = new MutationObserver(callback)
        this.observer.observe(this.scroller, config)
      },
      bindIScrollEventHandler () {
        this.$scroll.on('scrolling', this.onScroll)
        this.$scroll.on('scrollEnd', this.onScrollEnd)
        this.$scroll.on('scrollTo', this.onScrollTo)
      },
      unbindIScrollEventHandler () {
        this.$scroll.off('scrolling', this.onScroll)
        this.$scroll.off('scrollEnd', this.onScrollEnd)
        this.$scroll.off('scrollTo', this.onScrollTo)
      },
      bindIndicatorEventHandler () {
        document.addEventListener(moveEvent, this._move)
        document.addEventListener(endEvent, this._end)
      },
      unbindIndicatorEventHandler () {
        document.removeEventListener(moveEvent, this._move)
        document.removeEventListener(endEvent, this._end)
      },
      _start (e) {
        const point = e.touches ? e.touches[0] : e
        this.point.startY = point.pageY
        this.point.startIndicatorTop = this.indicatorTop
        this.indicatorDuration = 0
        this.point.reviseValue = point.clientY - this.$refs.indicator.getBoundingClientRect().top

        this.unbindIScrollEventHandler()
        this.bindIndicatorEventHandler()
      },
      _move (e) {
        const point = e.touches ? e.touches[0] : e
        const distanceY = this.point.startY - point.pageY - this.point.startIndicatorTop - this.point.reviseValue
        const percent = (distanceY) / this.indicatorContainerHeight
        const newIndicatorTop = -(this.maxIndicatorTop * percent)

        this.indicatorTop = newIndicatorTop > this.maxIndicatorTop ? this.maxIndicatorTop : (newIndicatorTop < 0) ? 0 : newIndicatorTop

        const iscrollNewY = (this.indicatorTop / this.maxIndicatorTop) * this.scrollableHeight

        this.$scroll.scrollTo(0, -iscrollNewY, 0)

        // console.log('startY : ' + this.point.startY + ' / moveY: ' + point.pageY + ' / distanceY :' + distanceY + ' / newMTop : ' + newIndicatorTop + ' / ' + iscrollNewY + ' / ' + this.point.startIndicatorTop)
      },
      _end (e) {
        if (this.$scroll.currentPage) {
          const point = e.changedTouches ? e.changedTouches[0] : e
          const distanceY = this.point.startY - point.pageY - this.point.startIndicatorTop - this.point.reviseValue
          const percent = (distanceY) / this.indicatorContainerHeight
          const newIndicatorTop = -(this.maxIndicatorTop * percent)

          this.indicatorTop = newIndicatorTop > this.maxIndicatorTop ? this.maxIndicatorTop : (newIndicatorTop < 0) ? 0 : newIndicatorTop

          const iscrollNewY = (this.indicatorTop / this.maxIndicatorTop) * this.scrollableHeight

          this.$scroll.currentPage = this.$scroll._nearestSnap(0, -iscrollNewY)
          if (!this.$scroll.pages) {
            return
          }
          if (this.$scroll.currentPage.pageY === this.$scroll.pages[0].length) this.$scroll.currentPage.pageY = (this.$scroll.currentPage.pageY - 5 > -1) ? this.$scroll.currentPage.pageY - 5 : 0
          this.$scroll.goToPage(this.$scroll.currentPage.pageX, this.$scroll.currentPage.pageY, 100)
          console.log('pageY _end - ' + this.$scroll.currentPage.pageY)
        }

        this.indicatorDuration = 500

        this.unbindIndicatorEventHandler()
        this.bindIScrollEventHandler()
      },
      onClickRunway (e) {
        if (this.nonScroll) return

        this.scrolling = true

        const point = e.touches ? e.touches[0] : e
        const runwayPoint = this.$refs.runway.getBoundingClientRect()
        const pageY = point.pageY - runwayPoint.top
        const percentY = pageY / 200
        const newY = this.maxIndicatorTop * percentY
        const iscrollNewY = this.scrollableHeight * percentY

        this.indicatorTop = newY
        if (this.$scroll.currentPage) {
          this.$scroll.currentPage = this.$scroll._nearestSnap(0, -iscrollNewY)
          if (this.$scroll.currentPage.pageY === this.$scroll.pages[0].length) this.$scroll.currentPage.pageY = (this.$scroll.currentPage.pageY - 5 > -1) ? this.$scroll.currentPage.pageY - 5 : 0
          this.$scroll.goToPage(this.$scroll.currentPage.pageX, this.$scroll.currentPage.pageY, 100)
          console.log('pageY _clickrunway - ' + this.$scroll.currentPage.pageY)
        } else {
          this.$scroll.scrollTo(0, -iscrollNewY, 100)
        }
      },
      onScroll (direction, newY) {
        this.indicatorDuration = 0
        this.scrolling = true
        this.indicatorTop = Math.floor(this.maxIndicatorTop * Math.abs(newY) / this.scrollableHeight)
      },
      onScrollTo (x, y, time, easing) {
        this.indicatorTop = Math.floor(this.maxIndicatorTop * Math.abs(y) / this.scrollableHeight)
      },
      onScrollEnd () {
        this.indicatorDuration = 500
        this.scrolling = false
      },
      onClickDoubleArrow (up) { // 1page true is up, false is down
        if (this.scrolling || this.nonScroll) return

        const now = Date.now()
        if (Math.abs(this.now - now) < 300) return
        this.now = now
        const pageHeight = this.$scroll.wrapperHeight
        let newY = (up) ? this.$scroll.y + pageHeight : this.$scroll.y - pageHeight
        newY = (newY < -this.scrollableHeight) ? -this.scrollableHeight : (newY >= 0) ? 0 : newY
        this.$scroll.scrollTo(0, newY)
        this.$scroll.currentPage = this.$scroll._nearestSnap(0, newY)
        if (!this.$scroll.pages) {
          return
        }
        if (this.$scroll.currentPage.pageY === this.$scroll.pages[0].length) this.$scroll.currentPage.pageY = (this.$scroll.currentPage.pageY - 5 > -1) ? this.$scroll.currentPage.pageY - 5 : 0
      },
      onClickArrow (up) { // 1step
        if (this.scrolling || this.nonScroll) return

        const now = Date.now()
        if (Math.abs(this.now - now) < 300) return
        this.now = now

        const currentPage = this.$scroll.currentPage

        if (currentPage && currentPage !== undefined) {
          if (up) {
            console.log('pageY up - ' + this.$scroll.currentPage.pageY)
            this.$scroll.prev()
          } else {
            if (!this.isBottom(this.bottomHeight)) {
              this.$scroll.next()
            } else {
              if (-this.scrollableHeight === this.$scroll.scroller.getBoundingClientRect().top) return
              this.$scroll.scrollTo(0, -this.scrollableHeight, 100)
              this.$scroll.currentPage = this.$scroll._nearestSnap(0, -this.scrollableHeight)
              if (this.$scroll.currentPage.pageY === this.$scroll.pages[0].length) this.$scroll.currentPage.pageY = (this.$scroll.currentPage.pageY - 5 > -1) ? this.$scroll.currentPage.pageY - 5 : 0
              console.log('pageY down - ' + this.$scroll.currentPage.pageY)
            }
          }
        } else {
          const scrollerPostion = this.$scroll.scroller.getBoundingClientRect()
          let newY = (up) ? scrollerPostion.top + this.itemHeight : scrollerPostion.top - this.itemHeight
          newY = (newY < -this.scrollableHeight) ? -this.scrollableHeight : (newY >= 0) ? 0 : newY
          this.$scroll.scrollTo(0, newY)
        }
      },
      isBottom (gap = 0) {
        const scrollerY = this.$scroll.scroller.getBoundingClientRect().top

        return ((this.scrollableHeight + scrollerY) <= gap && scrollerY !== 0)
      }
    },
    beforeDestroy () {
      if (this.observer) this.observer.disconnect()
    }
  }
</script>
<style lang="scss" scoped>

</style>
