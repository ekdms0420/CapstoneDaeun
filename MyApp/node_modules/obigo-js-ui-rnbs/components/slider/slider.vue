<template>
  <div
    class="obg-slider"
    :class="[mode + '-mode', { 'obg-slider-disabled': disabled }]"
    :style="{ 'width': sliderWidth + 'px'}"
    data-type="focus-control-able"
  >
    <button  v-if="isStepMode"
             @mousedown="start"
             @mouseup="end"
             @mouseleave="end"
             @touchstart="start"
             @touchend="end"
             @touchcancel="end"
             @touchleave="end"
             :class="['obg-button', 'control-button', {'disabled':min === value}]"
             @click.stop="onClickButton(false, $event)">
      <div>
        <div v-if="buttonLabel && buttonLabel.start" class="step-slider-label-box">
          <div v-if="isMinusLabel()" class="minus"></div>
          <div v-if="isPlusLabel()" class="plus"></div>
          {{buttonLabelText('start')}}
        </div>
      </div>
      <div class="icon-box">
        <span class="button-icon pre"><i class="obg-icon-go-pre"></i></span>
      </div>
    </button>
    <button v-if="hasIndicator" class="outer" :class="{'is-off':isOff}" @click.stop="onTurnOnOff">
      <div class="area">
        <div class="indicator">
          {{indicatorText}}
        </div>
      </div>
    </button>
    <div class="obg-slider-content" :class="{'is-off':isOff}"
         ref="content" @mousedown.prevent="onClickBar" @touchstart.prevent="onClickBar">
      <div class="obg-slider-runway" :style="{ 'border-top-width': runwayHeight + 'px' }" ></div>
      <div class="obg-slider-buffer" :style="{ width: bufferPercent + '%', height: progressHeight + 'px' }" ></div>
      <div class="obg-slider-progress" :class="{'is-none': !hasProgress}" :style="{ width: progress + '%', height: progressHeight + 'px' }" ></div>
      <div
        class="obg-slider-thumb"
        :class="{'animate-scale': thumbScale, 'start': (progress === 0), 'end': (progress === 100)}"
        ref="thumb"
        :style="{ left: progress + '%' }"
        @mousedown="start"
        @mouseup="end"
        @touchstart="start"
        @touchend="end"
        @touchcancel="end"
        @touchleave="end"
      >
        <span v-if="thumbLabel" class="obg-slider-current-value">{{progress}}</span>
      </div>
      <div v-if="isStepMode && showTick" class="obg-slider-top-tick-box">
        <div v-for="(n, i) of (step + 1)" class="obg-slider-tick"></div>
      </div>
      <div v-if="isStepMode && showTick" class="obg-slider-bottom-tick-box">
        <div v-for="(n, i) of (step + 1)" class="obg-slider-tick"></div>
      </div>
    </div>
    <button  v-if="isStepMode"
             @mousedown="start"
             @mouseup="end"
             @mouseleave="end"
             @touchstart="start"
             @touchend="end"
             @touchcancel="end"
             @touchleave="end"
             class="obg-button control-button"
             :class="{'disabled':max === value}"
             @click.stop="onClickButton(true, $event)">
      <div class="icon-box">
        <span class="button-icon next"><i class="obg-icon-go-next"></i></span>
      </div>
      <div>
        <div v-if="buttonLabel && buttonLabel.end" class="step-slider-label-box">
          <div v-if="isMinusLabel('end')" class="minus"></div>
          <div v-if="isPlusLabel('end')" class="plus"></div>
          {{buttonLabelText('end')}}
        </div>
      </div>
    </button>
  </div>
</template>

<script type="text/babel">
  /**
   * @see Renault, Nissan
   * @class slider
   * @classdesc components/slider
   * @param {slot} [slot='start']
   * @param {slot} [slot='end']
   * @param {string} [mode='slider'] others are 'range', 'step'
   * @param {string} [indicatorLabel='OFF'] indicator text
   * @param {object} [controlLabel={start:'minus', end: 'plus'}] control button label
   * @param {number} [min=0]
   * @param {number} [max=100]
   * @param {number} [step=1] min=1, max=20
   * @param {number} [value]
   * @param {number} [barHeight=0] height of total bar
   * @param {number} [progressBarHeight=0] height of progress bar
   * @param {number} [sliderWidth=454]
   * @param {boolean} [draggable=true]
   * @param {boolean} [disabled=false]
   * @param {boolean} [isOnlyStep=false]
   * @param {boolean} [hasProgress=true]
   * @param {boolean} [hasIndicator=false]
   * @param {boolean} [showTick=true]
   * @param {number} [buffer=0]
   * @param {boolean} [isFocus=false]
   * @param {boolean} [thumbScale=true]
   * @param {boolean} [thumbLabel=false]
   * @param {event} [input]
   *
   * @example
   * <obg-slider
   *  class="slider"
   *  v-model="model"
   *  :min="0"
   *  :max="100" @input="onInput"
   *  ></obg-slider>
   */
  import draggable from '../../features/draggable'
  import button from '../button'
  import focusControlMixin from '../../mixins/focus-control'

  const STEP_MIN = 1
  const STEP_MAX = 20
  export default {
    name: 'obg-slider',
    components: {
      'obg-button': button
    },
    mixins: [focusControlMixin],
    props: {
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      step: {
        type: Number,
        default: STEP_MIN,
        validator (val) {
          return val >= STEP_MIN && val <= STEP_MAX
        }
      },
      disabled: {
        type: Boolean,
        default: false
      },
      value: {
        type: Number
      },
      barHeight: {
        type: Number,
        default: 0
      },
      progressBarHeight: {
        type: Number,
        default: 0
      },
      draggable: {
        type: Boolean,
        default: true
      },
      isFocus: {
        type: Boolean,
        default: false
      },
      sliderWidth: {
        type: Number,
        default: 454
      },
      thumbLabel: {
        type: Boolean,
        default: false
      },
      thumbScale: {
        type: Boolean,
        default: true
      },
      mode: {
        type: String,
        default: 'slider'
      },
      buffer: {
        type: Number,
        default: 0
      },
      isOnlyStep: {
        type: Boolean,
        default: false
      },
      hasProgress: {
        type: Boolean,
        default: true
      },
      hasIndicator: {
        type: Boolean,
        default: false
      },
      showTick: {
        type: Boolean,
        default: true
      },
      indicatorLabel: {
        type: String,
        default: 'OFF'
      },
      buttonLabel: {
        type: Object,
        default: undefined,
        validator (val) {
          if (typeof val === 'undefined') {
            return true
          }
          return val && val.start && val.end
        }
      }
    },
    computed: {
      progress () {
        const value = this.value
        if (typeof value === 'undefined' || value === null || value === 0) return 0
        if (this.value >= this.max) {
          return 100
        } else if (this.value <= this.min) {
          return 0
        }
        return Math.floor((value - this.min) / (this.max - this.min) * 100)
      },
      bufferPercent () {
        const buffer = this.buffer
        if (typeof buffer === 'undefined' || buffer === null || buffer === 0) return 0
        if (this.buffer >= this.max) {
          return 100
        } else if (this.buffer <= this.min) {
          return 0
        }
        return Math.floor((buffer - this.min) / (this.max - this.min) * 100)
      },
      isStepMode () {
        return this.mode === 'step'
      }
    },
    watch: {
      isFocus (isFocus) {
        if (isFocus) {
          this.$refs.thumb.classList.add('focus')
        } else {
          this.$refs.thumb.classList.remove('focus')
        }
      },
      max (val) {
        this.stepUnit = Math.ceil((this.max - this.min) / this.step)
      },
      min (val) {
        this.stepUnit = Math.ceil((this.max - this.min) / this.step)
      },
      step (val) {
        this.stepUnit = Math.ceil((this.max - this.min) / this.step)
      }
    },
    data () {
      return {
        indicatorText: this.indicatorLabel,
        active: false,
        isOff: false,
        runwayHeight: 2,
        progressHeight: 2
      }
    },
    mounted () {
      // init default value for step mode
      if (this.mode === 'step') {
        this.runwayHeight = 6
        this.progressHeight = 10
      }
      if (this.barHeight > 0) this.runwayHeight = this.barHeight
      if (this.progressBarHeight > 0) this.progressHeight = this.progressBarHeight
      const thumb = this.$refs.thumb
      const content = this.$refs.content
      this.stepUnit = Math.ceil((this.max - this.min) / this.step)
      const getThumbPosition = () => {
        const contentBox = content.getBoundingClientRect()
        const thumbBox = thumb.getBoundingClientRect()
        return {
          left: thumbBox.left - contentBox.left,
          top: thumbBox.top - contentBox.top,
          contentBox: contentBox,
          thumbBox: thumbBox
        }
      }
      if (this.draggable) {
        let dragState = {}
        draggable(thumb, {
          start: (event) => {
            if (this.disabled || this.isOff) return
            const position = getThumbPosition()
            const pageX = event.touches ? event.touches[0].pageX : event.pageX
            dragState = {
              thumbStartLeft: position.left,
              thumbStartTop: position.top,
              eventStartX: pageX
            }
            this.$emit('dragstart')
          },
          drag: (event) => {
            const pageX = event.touches ? event.touches[0].pageX : event.pageX
            const distance = Math.abs(pageX - dragState.eventStartX)
            if (this.disabled || this.isOff || distance < 10) return
            const contentBox = content.getBoundingClientRect()
            const thumbWidthDividerVal = ['slider', 'step'].indexOf(this.mode) > -1 ? 5 : 2
            let thumbFactor = (this.$refs.thumb.getBoundingClientRect().width / thumbWidthDividerVal) / contentBox.width
            const deltaX = pageX - contentBox.left - dragState.thumbStartLeft
            const newPosition = (dragState.thumbStartLeft + deltaX) - (dragState.thumbStartLeft + deltaX) % (contentBox.width / this.stepUnit)
            thumbFactor = Number((thumbFactor / this.step).toFixed(1))
            let newProgress = newPosition / contentBox.width - thumbFactor
            if (newProgress < 0) {
              newProgress = 0
            } else if (newProgress > 1) {
              newProgress = 1
            }
            this.$emit('input', Math.round(this.min + newProgress * (this.max - this.min)))
          },
          end: () => {
            if (this.disabled || this.isOff) return
            let newProgress = this.value
            if (this.isOnlyStep) {
              newProgress = this.getOnlyStep(newProgress)
            }
            thumb.classList.remove('active')
            this.$emit('input', newProgress)
            dragState = {}
            this.$emit('dragend')
          }
        })
      }

      this.$thumb = this.$el.querySelector('.obg-slider-thumb')
      this.$runway = this.$el.querySelector('.obg-slider-content')
      this.$on('focusin', this.onFocusIn)
      this.$on('focusout', this.onFocusOut)
    },
    methods: {
      isMinusLabel (where = 'start') {
        return this.buttonLabel && ['minus', 'plus'].indexOf(this.buttonLabel[where]) > -1
      },
      isPlusLabel (where = 'start') {
        return this.buttonLabel && ['plus'].indexOf(this.buttonLabel[where]) > -1
      },
      buttonLabelText (where = 'start') {
        if (this.buttonLabel && ['minus', 'plus'].indexOf(this.buttonLabel[where]) === -1) {
          return this.buttonLabel[where]
        }
        return ''
      },
      start (evt) {
        if (evt.currentTarget.classList.contains('disabled')) {
          return
        }
        evt.currentTarget.classList.add('active')
      },
      end (evt) {
        evt.currentTarget.classList.remove('active')
      },
      getOnlyStep (newProgress) {
        let nextVal = newProgress
        let nextStep = Math.round(newProgress / this.stepUnit)
        nextVal = nextStep * this.stepUnit
        if (nextVal > this.max) {
          nextVal = this.max
        }
        return nextVal
      },
      onClickBar (event) {
        if (this.disabled || this.isOff) {
          return
        }
        const pageX = (event.touches) ? event.touches[0].clientX : event.pageX
        if (this.draggable && ['slider', 'step'].indexOf(this.mode) > -1) {
          const contentBox = this.$refs.content.getBoundingClientRect()
          const deltaX = pageX - contentBox.left
          let newProgress = Math.floor(this.max * deltaX / contentBox.width)
          if (newProgress < this.min) {
            newProgress = this.min
          } else if (newProgress > this.max) {
            newProgress = this.max
          }
          if (this.isOnlyStep) {
            newProgress = this.getOnlyStep(newProgress)
          }
          this.$emit('input', newProgress)
          event.stopPropagation()
        }
      },
      onClickButton (isIncrease = false, event) {
        if (this.disabled || this.isOff) {
          return
        }
        let curStep = this.value / this.stepUnit
        let remainder = this.value % this.stepUnit
        let operator = isIncrease ? 1 : remainder > 0 ? 0 : -1
        let nextStep = parseInt(curStep + operator)
        if (isIncrease) {
          if (nextStep > this.step + 1) {
            return
          }
        } else {
          if (nextStep < 0) {
            return
          }
        }
        let nextVal = nextStep * this.stepUnit
        if (nextVal > this.max) {
          nextVal = this.max
        }
        this.$emit('input', nextVal)
      },
      onTurnOnOff () {
        this.isOff = !this.isOff
      },
      onControlIn () {
        this.$el.classList.remove('obg-focus')
        this.$thumb.classList.add('obg-focus')
        this.onFocusIn()
      },
      onRotate ({mode}) {
        // if (this.rotateListener) {
        //   this.rotateListener({mode})
        //   return
        // }
        if (mode === this.hardkeyCodes.mode.HARDKEY_MODE_RIGHT) {
          this.onClickButton(true)
        } else {
          this.onClickButton()
        }
      },
      onRotateClick () {
        this.$el.classList.add('obg-focus')
        this.$thumb.classList.remove('obg-focus')
        this.onFocusOut()
      },
      exitFocusMode () {
        this.onFocusOut()
        this.exitFocusControlMode()
        this.$focus.exitFocusMode()
      },
      onFocusIn () {
        this.$el.addEventListener('mousedown', this.exitFocusMode)
        this.$el.addEventListener('touchstart', this.exitFocusMode)
        this.$runway.addEventListener('mousedown', this.exitFocusMode)
        this.$runway.addEventListener('touchstart', this.exitFocusMode)
      },
      onFocusOut () {
        this.$el.removeEventListener('mousedown', this.exitFocusMode)
        this.$el.removeEventListener('touchstart', this.exitFocusMode)
        this.$runway.removeEventListener('mousedown', this.exitFocusMode)
        this.$runway.removeEventListener('touchstart', this.exitFocusMode)
      }
    }
  }
</script>

<style lang="scss" scoped>
  /*
    @import '../../styles/common/colors.variables.scss';
    */

  @keyframes thumb-scale {
    0% {
      transform: scale(0.7)
    }
    100% {
      transform: scale(1)
    }
  }

  .step-mode {
    position: relative;
    display: flex;
    align-items: center;
    height: inherit;
    .control-button {
      font-size: 45px;
      width: auto;
      margin: 0 10px;
      &:active, &.active {
        text-shadow: 0 0 8px white;
        .icon-box{
          background: radial-gradient(ellipse at center, #ffffff 0%, rgba(255, 255, 255, 0) 65%);
        }
        .minus {
          box-shadow: 0 0 8px white;
        }
        .plus {
          box-shadow: 0 0 8px white;
        }
      }
      .icon-box{
        height: 74px;
        width: 74px;
        display: flex;
        .button-icon{
          height: auto;
          width: 55px;
          display: flex;
          margin: auto;
          &.pre{
            justify-content: flex-start;
          }
          &.next{
            justify-content: flex-end;
          }
        }
      }
      .step-slider-label-box {
        margin: 5px;
        width: 45px;
        height: 45px;
        display: inline-block;
        text-align: center;
        div.slider-label-text {
          font-size: 45px;
          text-align: center;
          margin: auto;
        }
        .minus {
          border: solid 2px white;
          margin: auto;
          display: block;
          width: 32px;
          margin-top: 25px;
        }
        .plus {
          border: solid 2px white;
          margin: auto;
          margin-top: -18px;
          display: block;
          height: 32px;
          width: 4px;
        }
      }
    }
    .is-off {
      div.obg-slider-progress {
        display: none;
      }
      .obg-slider-thumb{
        display: none;
      }
    }
    & > .obg-slider-content {
      position: relative;
      flex: 1;
      & > .obg-slider-buffer {
        position: absolute;
        display: block;
        top: 50%;
        width: 0;
        height: 2px !important;
        margin-top: -2px;
      }
      & > .obg-slider-progress {
        &.is-none{
          display: none;
        }
        position: absolute;
        display: block;
        top: -2px;
        width: 0;
      }
    }
    .obg-slider-label {
      font-size: 44pt;
    }
    & > .outer {
      width: 115px;
      height: 100%;
      margin-right: 16px;
      &.is-off .area {
        & .indicator{
          color: #fff;
        }
        &:before {
          background-color: #ff8f1c;
        }
      }
      .area {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        flex-direction: row-reverse;
        &:before {
          content: '';
          position: absolute;
          /*top: 35px;*/
          /*right: 15px;*/
          /*display: block;*/
          margin: auto 16px auto -5px;
          width: 22px;
          height: 22px;
          border-radius: 100%;
          background-color: #4b4b4b;
        }
        & .indicator {
          width: 100%;
          font-size: 45px;
          color: #4b4b4b;
          text-align: left;
        }
      }
    }
    &  > .obg-slider-content {
      height: 32px;
      & > .obg-slider-runway {
        position: absolute;
        top: 14px;
        transform: translateY(-50%);
        left: 0;
        border-top: 1px solid #a1a2b3;
        width: 100%;
        border-radius: 5px;
      }
      & > div.obg-slider-progress {
        top: 14px;
        position: absolute;
        background: white;
        height: 6px;
        border-radius: 5px;
        transform: translateY(-50%);
        left: 0;
      }
      & > .obg-slider-progress:before {
        display: none;
      }
      & > .obg-slider-thumb {
        position: absolute;
        top: -10px;
        margin-left: -25px;
        width: 50px;
        height: 50px;
        &:before {
          content: '';
          display: block;
          position: absolute;
          top: 13px;
          left: 14px;
          width: 22px;
          height: 22px;
          border-radius: 14px;
          background-color: orange;
        }
        &.animate-scale {
          &.active {
            &:before{
              box-shadow: 0 0 10px orange;
            }
          }
        }
        &.animate-scale:active:before {
          box-shadow: 0 0 10px orange;
        }
        &:active:before {
          -webkit-transform: scale(1.5);
          transform: scale(1.5);
          background-color: orange;
        }
      }
    }
    .obg-button-default{
      position: relative;
      &:active, .active{
        background: transparent;
        &:before{
          position: absolute;
          top: 7px;
          left: 10%;
          margin: auto;
          content: '';
          display: block;
          width: 84px;
          height: 84px;
        }
      }
    }
    .obg-slider-top-tick-box {
      display: flex;
      justify-content: space-between;
      margin: 0 -1px;
    }
    .obg-slider-bottom-tick-box {
      display: flex;
      justify-content: space-between;
      margin: 0 -1px;
      margin-top: 18px;
    }
    .obg-slider-tick {
      height: 6px;
      background-color: rgba(255, 255, 255, 0.25);
      border-radius: 5px;
      width: 3px;
    }
  }

</style>
