<template>
  <div class='obg-v-cover-flow' :class='{"isEmpty": isEmpty}'>
    <div class='scroll-container' ref="scrollContainer">
      <div class='dummy-item top' v-if="hideDummyItem == false"/>
      <slot></slot>
      <div class='dummy-item' v-if="hideDummyItem == false"/>
    </div>
  </div>
</template>

<script>
  import IScroll from '../../features/iscroll'
  import spm from './scroll-position-manager'
  import slide from './slide'

  const UP_THRESHOLD = 370
  const DOWN_THRESHOLD = 280
  const CENTER_POSITION = 340
  //  const CENTER_TOP = 252
  const isTouchSupported = 'ontouchstart' in window
  const startEvent = isTouchSupported ? 'touchstart' : 'mousedown'
  /**
   * @see Renault, Nissan
   * @class v-cover-flow
   * @classdesc components/cover-flow-portrait
   * @param {boolean} [hideDummyItem=false] hide/show last dummy item.
   * @param {number} [targetElementIndex=0] scroll to targetElement when updated
   * @param {boolean} [loop=true]
   * @param {array} [slidePositionMatrix]
   * @param {array} [centerPosition={x: 300, z: 410}]
   * @param {number} [value=0]
   * @param {string} [listKey] unique list id in page.<br/>if do not define this property, List component can not save last scroll position.<br/>and be careful do not duplicate with another List in same page.
   * @example
   * <obg-v-cover-flow>
   *  <obg-v-cover-flow-slide>slide1</obg-v-cover-flow-slide>
   *  <obg-v-cover-flow-slide>slide1</obg-v-cover-flow-slide>
   *  <obg-v-cover-flow-slide>slide1</obg-v-cover-flow-slide>
   * </obg-v-cover-flow>
   */
  export default {
    name: 'obg-v-cover-flow',
    props: {
      hideDummyItem: {
        type: Boolean,
        default: false
      },
      targetElementIndex: {
        type: Number,
        default: 0
      },
      listKey: {
        type: String
      },
      slidePositionMatrix: {
        type: Array,
        default: () => []
      },
      loop: {
        type: Boolean,
        default: true
      },
      centerPosition: {
        type: Object,
        default: () => {
          return {
            x: 300,
            y: 410
          }
        }
      },
      value: {
        type: Number,
        default: 0
      }
    },
    data () {
      return {
        isEmpty: false,
        childCount: 0,
        index: this.value,
        scrollDuration: 50,
        momentum: false,
        isScrolling: false
      }
    },
    watch: {
      value (newVal, oldVal) {
        this.index = newVal
        this.addCenterClass(true)
        this.scrollToCenter(document.querySelector('[index="' + (this.index + '') + '"]'))
      }
    },
    methods: {
      getCenterElementIndex (y = CENTER_POSITION) {
        const $scroll = this.$refs.scrollContainer
        const scrollPosition = $scroll.getBoundingClientRect()

        const isBottom = scrollPosition.height - 820 + scrollPosition.top < 150
        const isTop = scrollPosition.top > -150

        if (isBottom) return this.$slots.default.length - 1
        if (isTop) return 0

        let $center = document.elementFromPoint(this.centerPosition.x, y)

        if ($center.attributes.index) {
          return Number($center.attributes.index.value)
        } else {
          $center = document.elementFromPoint(this.centerPosition.x, y + 16) // check margin
          if ($center.attributes.index) {
            return Number($center.attributes.index.value)
          } else {
            $center = $center.parentElement
            return Number($center.attributes.index.value)
          }
        }
      },
      getElementByIndex (val = this.index) {
        return document.querySelector('[index="' + (val + '') + '"]')
        // return this.$slots.default[val].elm
      },
      addCenterClass (isMoving = false) {
        if (this.momentum) return

        const duration = (isMoving) ? 0 : 200
        clearTimeout(this.classtimer)

        this.classtimer = setTimeout(() => {
          this.removeCenterClass()
          const $center = this.getElementByIndex()
          const $prev = $center.previousElementSibling
          const $next = $center.nextElementSibling
          $center.classList.add('center')
          if ($prev) {
            $prev.classList.add('center-1')
          }
          if ($next) {
            $next.classList.add('center-1')
          }
        }, duration)
      },
      scrollToCenter ($el) {
        const index = ($el.attributes.index) ? Number($el.attributes.index.value) : Number($el.parentElement.attributes.index.value)

        let newY = (index === 0) ? -13 : index * 95 + 20

        this.unBindScrollEventHandler()

        clearTimeout(this.eventTimer)

        this.$scroll.scrollTo(0, -newY, 100)

        this.$nextTick(() => {
          this.eventTimer = setTimeout(() => {
            this.bindScrollEventHandler()
          }, 150)
        })
      },
      onMomentum () {
        this.momentum = true
        this.isScrolling = false
        this.removeCenterClass()
        this.$refs.scrollContainer.addEventListener(startEvent, this.onTouchDuringMomentum)
      },
      onTouchDuringMomentum () {
        if (this.momentum) {
          this.momentum = false
          this.isScrolling = true
        }
        this.$refs.scrollContainer.removeEventListener(startEvent, this.onTouchDuringMomentum)
      },
      onScroll (direction) {
        const $scroll = this.$refs.scrollContainer
        const scrollPosition = $scroll.getBoundingClientRect()

        const isBottom = scrollPosition.height - 820 + scrollPosition.top < 150
        const isTop = scrollPosition.top > -150

        if (isBottom) {
          this.index = this.$slots.default.length - 1
        } else if (isTop) {
          this.index = 0
        } else {
          const positionY = (direction > 0) ? UP_THRESHOLD : DOWN_THRESHOLD
          const $center = document.elementFromPoint(this.centerPosition.x, positionY)
          if ($center.attributes.index) {
            this.index = Number($center.attributes.index.value)
          }
          if ($center.parentElement.attributes.index) {
            this.index = Number($center.parentElement.attributes.index.value)
          }
        }

        this.addCenterClass(true)
      },
      onScrollStart (e) {
        this.isScrolling = true
      },
      onClickSlide ($el, index) {
        if (this.index === index) return
        this.index = index

        this.addCenterClass()
        this.scrollToCenter($el)
      },
      removeCenterClass () {
        const className = ['center', 'center-1']
        className.forEach(str => {
          let $elements = this.$el.getElementsByClassName(str)
          if ($elements.length > 0) {
            for (let i = 0; i < $elements.length; i++) {
              $elements[i].classList.remove(str)
            }
          }
        })
      },
      bindScrollEventHandler () {
        this.$refs.scrollContainer.addEventListener('transitionend', this.onTransitionEnd)
        this.$scroll.on('scrollEnd', this.scrollEnd)
        this.$scroll.on('scrolling', this.onScroll)
        this.$scroll.on('momentum', this.onMomentum)
        this.$scroll.on('scrollCancel', this.onScrollCancel)
        this.$scroll.on('scrollStart', this.onScrollStart)
      },
      unBindScrollEventHandler () {
        this.$refs.scrollContainer.removeEventListener('transitionend', this.onTransitionEnd)
        this.$scroll.off('scrollEnd', this.scrollEnd)
        this.$scroll.off('scrolling', this.onScroll)
        this.$scroll.off('momentum', this.onMomentum)
        this.$scroll.off('scrollStart', this.onScrollStart)
      },
      getScroll () {
        return this.$scroll
      },
      focusIn (index, direction) { // TODO 로직 수정 필요
        /*
         * 리스트 아이템의 높이는 모두 같다는 전제
         */

        let itemHeight = this.$scroll.pages[0][0].height         // 만약 iscroll의 pages속성을 없앤다면, 수정되어야 할 부분!!
        let wrapperHeight = this.$scroll.wrapperHeight
        let fixedFocusPos = 0
        let remain = itemHeight - ((wrapperHeight - (this.hideDummyItem ? 0 : 78)) % itemHeight)
        let itemsInPage = Math.floor((wrapperHeight - (this.hideDummyItem ? 0 : 78)) / itemHeight) - (remain === itemHeight ? 1 : 0)
        let nowPage = this.$scroll.currentPage.pageY

        if (direction === 'right') {
          fixedFocusPos = itemsInPage
          if (index - nowPage > itemsInPage - 1) {
            this.$scroll.goToPage(0, index - fixedFocusPos + 1, 200)
          }
        } else if (direction === 'left') {
          fixedFocusPos = 2
          if (index === nowPage) {
            this.$scroll.goToPage(0, nowPage - 1, 200)
          }
        } else {
          this.$scroll.goToPage(0, 0, 100)
        }
      },
      makeScroll () {
        if (this.$el.querySelectorAll('.scroll-container > .obg-v-cover-flow-slide').length === 0 || this.$slots.default === undefined || this.$slots.default.length === 0) {
          this.isEmpty = true
          return
        }
        this.isEmpty = false
        this.$scroll = new IScroll(this.$el, {
          probeType: 2,
          bounce: false,
          mouseWheel: false,
          scrollbars: true,
          fadeScrollbars: true,
          interactiveScrollbars: false,
          scrollXThreshold: slide.horiThreshold,
          scrollYThreshold: slide.vertiThreshold,
          click: true,
          disableMouse: !(!('ontouchstart' in window) && ('onmousedown' in window)),
          disablePointer: true,
          disableTouch: !(('ontouchstart' in window) && ('onmousedown' in window)),
          // snap: '.obg-v-cover-flow-slide',
          deceleration: 0.001,
          dummyItem: !this.hideDummyItem
        })
        this.bindScrollEventHandler()
        var lastPos = 0
        if (this.$router) { // 팝업의 컴포넌트로 list를 생서할 시 router는 전달되지 않으므로 라우터 검사 후 라우터 사용
          lastPos = spm.get(this.listKey + this.$router.history.current.fullPath)
        }
        if (this.$router && this.$router.isBack === true && lastPos !== undefined) {
          this.$scroll.goToPage(0, lastPos.pageY, 0)    // scrollTo를 사용하면 iscroll의 pages속성을 업데이트하지않아 snap이 적용된 스크롤 동작이 정상적이지 않음.
        } else {
          // this.scrollToElement(this.targetElementIndex)
          // this.scrollToCenter(this.getElementByIndex(this.targetElementIndex))
          this.scrollToCenter(this.getElementByIndex(this.index))
        }
      },
      onTransitionEnd (e) {
        if (e.propertyName !== 'transform') return

        if (this.momentum) {
          this.momentum = false
          const idx = this.getCenterElementIndex()
          this.index = idx
          this.scrollToCenter(this.getElementByIndex(idx))
          this.addCenterClass()
        }
      },
      onScrollCancel (e) {
        this.onTransitionEnd({propertyName: 'transform'})
      },
      scrollEnd () {
        if (this.listKey !== undefined && this.$router) {
          spm.set(this.listKey + this.$router.history.current.fullPath, this.$scroll.currentPage)
        }
        if (this.isScrolling) {
          this.isScrolling = false
          this.scrollToCenter(this.getElementByIndex(this.index))
        }
      },
      refreshScroll () {
        if (this.$scroll) {
          this.itemsEl = this.$el.querySelectorAll('.obg-v-cover-flow-slide')
          if (this.itemsEl.length === 0 || this.$slots.default === undefined || this.$slots.default.length === 0) {
            this.isEmpty = true
            this.$scroll.destroy()
            this.$scroll = undefined
            return
          } else {
            this.isEmpty = false
            this.$scroll.refresh()
          }
        } else {
          this.makeScroll()
          this.itemsEl = this.$el.querySelectorAll('.obg-v-cover-flow-slide')
        }
      },
      // scrollToElement (index) {
      //   if (index !== undefined && this.$slots.default[index]) {
      //     this.$scroll.scrollToElement(this.$slots.default[index].elm, 0, 0, 0)
      //   }
      // },
      prev () {
        this.$scroll && this.$scroll.prev()
      },
      next () {
        this.$scroll && this.$scroll.prev()
      },
      goToIndex (index) {
        this.$scroll && this.$scroll.goToPage(0, index, 200)
      }
    },
    updated () {
      const nowScrollHeight = this.$el.firstChild.scrollHeight
      if (this.beforeScrollHeight !== nowScrollHeight) {
        this.refreshScroll()
        this.beforeScrollHeight = nowScrollHeight
      }

      this.childCount = this.$el.querySelectorAll('.scroll-container > .obg-v-cover-flow-slide').length

      if (this.isEmpty === false) {
        // this.scrollToElement(this.targetElementIndex)
        // this.scrollToCenter(this.getElementByIndex(this.index))
      }

      this.addCenterClass()
    },
    mounted () {
      this.itemsEl = []
      this.beforeFocusIndex = 0
      this.makeScroll()
      this.beforeScrollHeight = this.$el.firstChild.scrollHeight
      this.$on('updateScroll', this.refreshScroll)
      this.$on('updateIndex', this.onClickSlide)
      this.childCount = this.$el.querySelectorAll('.scroll-container > .obg-v-cover-flow-slide').length
      this.itemsEl = this.$el.querySelectorAll('.obg-v-cover-flow-slide')

      this.addCenterClass()
    },
    beforeDestroy () {
      if (this.$scroll) {
        this.$scroll.destroy()
        this.$scroll = undefined
      }
    }

  }
</script>
<style lang="scss" scoped>


</style>

